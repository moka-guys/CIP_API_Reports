from HTMLParser import HTMLParser
import requests
from authentication import APIAuthentication
from bs4 import BeautifulSoup
import pdfkit
import os

class connect():
	def __init__(self):
		# call function to retrieve the api token
		self.token=APIAuthentication().get_token()

		# json with all interpretation_requests
		self.interpretationlist="https://cipapi.genomicsengland.nhs.uk/api/interpretationRequestsList/?format=json"

		self.proband_id=""

		self.list_of_reports=[]
		
		self.proxy={'http':'proxy.gstt.local:80'}

		self.org_name="Viapath"
		self.new_header="This result sheet has been generated by Viapath using data obtained from the Genomics England APIs."
		self.old_header="Genomics England, Queen Mary University of London,"

		self.new_banner_css="background-color: /#a3009b;\n    height: 100px;"
		self.existing_banner_css="background-color: /#007C83; /*#27b7cc;*/"
		
		self.html_reports="/home/mokaguys/Documents/GeL_reports/html/"
		self.pdf_dir="/home/mokaguys/Documents/GeL_reports/"
		
		self.config = pdfkit.configuration(wkhtmltopdf="/home/mokaguys/Apps/wkhtmltox/bin/wkhtmltopdf")
		
		self.html_report=""
		self.pdf_report=""
        
		
	def fetch_all_requests_json(self, probandid):
		'''This function returns all the cases that can be viewed by the user defined by the authentication token'''
		self.proband_id=probandid
		self.html_report=self.html_reports+self.proband_id+".html"
		self.pdf_report=self.pdf_dir+self.proband_id+".pdf"
		# use requests module to return all the cases available to you
		response = requests.get(self.interpretationlist, headers={"Authorization": "JWT " + self.token})
		# pass this in the json format to the parse_json function
		self.parse_json(response.json())
		
		
	def parse_json(self,json):
		'''This function takes the json file containing all cases. This can be parsed to look for the desired proband id'''
		#loop through the results
		for sample in json['results']:
			#print sample["proband"]
			
			# look for the desired proband id
			if sample["proband"]==self.proband_id:
				if sample["last_status"]=="blocked":
					pass
				else:
					print "match"
					# create a variable to hold the various cip versions
					max_cip_ver=0

					# loop through each report to find the highest cip_version
					for j in range(len(sample["interpreted_genomes"])):
						if int(sample["interpreted_genomes"][j]["cip_version"])>max_cip_ver:
							max_cip_ver=sample["interpreted_genomes"][j]["cip_version"]

					# for the highest cip version
					for j in range(len(sample["interpreted_genomes"])):
						if sample["interpreted_genomes"][j]["cip_version"]==max_cip_ver:
							# loop through the clinical reports(there may be multiple)
							for report in range(len(sample["interpreted_genomes"][j]["clinical_reports"])):
								print sample["interpreted_genomes"][j]["clinical_reports"][report]['url']
								# pull down the clinical report
								report=requests.get(sample["interpreted_genomes"][j]["clinical_reports"][report]['url'],headers={"Authorization": "JWT " + self.token},proxies=self.proxy)

								##write report to a text file
								#html_report_file=open("/home/mokaguys/Apps/CIP_API/"+str(report)+"_report.html",'w')
								#html_report_file.write(report.content)

								# create an beautiful soup object for the html clinical report
								soup=BeautifulSoup(report.content,"html.parser")

								#pass the object to the replace_gel_address function and update the object
								soup=self.replace_gel_address(soup)

								#pass to function to modify the header
								soup=self.remove_GeL_logo(soup)

								# pass to function to expand coverage
								soup=self.expand_coverage(soup)
								print soup
								
								with open(self.html_report, "w") as file:
									file.write(str(soup))
								#print self.html_report
								#print self.pdf_report
								self.create_pdf(self.pdf_report)
	
	def replace_gel_address(self,html):
		'''This function loops through the report html object and replaces the GeL address with a rider to say this is an internal report based on the information from the GeL API'''
		# notes is a list of all the p tags where the class == note
		notes=html.find_all("p", class_="note")
		# loop through each p tag and look for the containing the gel address (as defined in the init function)
                for note in range(len(notes)):
			# if the string is in the text
			if self.old_header in notes[note].get_text():
				# create a new <p> tag
				new_rpt_header=html.new_tag("p")
				# add in the new header to the tag string
                                new_rpt_header.string=self.new_header
				# create a new break tag
                                br=html.new_tag('br')
				# add the break tag to the end of the text string twice
                                new_rpt_header.insert(len(new_rpt_header),br)
                                new_rpt_header.insert(len(new_rpt_header),br)
				# insert the new tag into the html
                                notes[note].insert_before(new_rpt_header)
                                # remove the gel address tag
                                notes[note].extract()
				# return modified html
				return html

	def remove_GeL_logo(self,html):
		'''This function removes the gel logo and changes the css for the report banner'''
		# find the gel logo and remove it
		for img in html.find_all('img', class_="logo"):
			img.extract()
		# resize the banner so it doesn't shrink after the logo has been removed
		for banner in html.find_all('div', class_="banner-text"):
			del(banner['class'])
		return html


	def expand_coverage(self,html):
		'''Expand the coverage section'''
		# find the coverage div and delete so coverage seciton no longer needs to be clicked to be visible
		for section in html.find_all('div', id="coverage"):
			del(section['hidden'])

		# find the section header and remove text/hyperlink properties
		for section in html.find_all('a'):
			# find the coverage section
			if "Coverage Metrics" in section.get_text():
				# remove the extra styles no longer needed
				del(section['onclick'])
				del(section['style'])
				# create new tag and section title
				new_header="Coverage Report"
				# replace p with h3
				section.name="h3"
				# change the string
				section.string=new_header
		return html


	def create_pdf(self,report):
		options={'footer-right':'Page [page] of [toPage]','footer-left':'Date Created [isodate]'}
		pdfkit.from_file(self.html_report, report, options=options, configuration=self.config)
		
if __name__=="__main__":
	c=connect()
	proband_id=[50004174,50004235,50004232,50002772,50002730,50003797,50003798,50003759,50003809,50003800,50003801,50003802,50002721,50002727,50002728,50002729,50002768,50002769,50003313,50003317,50003319,50003320,50003390,50003508,50003514,50003516,50003553,50003761,50002417,50002422,50002425,50002559,50003799,50003808,50004010,50004021,50004024,50004025,50004026,50004204,50004233,50004238,50004239,50004450,50004683,50004698,50001829,50001871,50002023,50002251,50002413]
	for i in proband_id:
		c.fetch_all_requests_json(str(i))

